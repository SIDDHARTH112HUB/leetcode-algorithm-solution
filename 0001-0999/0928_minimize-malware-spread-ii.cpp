//Link: https://leetcode.com/problems/minimize-malware-spread-ii/ 
struct Union{
    unordered_map<int, int> p;
    unordered_map<int, int> clean;
    unordered_map<int, int> group;
    unordered_map<int, int> group2;
    int find(int m){
        if( p[m] != m )
            p[m] = find(p[m]);
        return p[m];
    }
    
    void combine(int m1, int m2){
        if( p.find(m1) == p.end() ){
            group[m1] = 1;
            p[m1] = m1;
        }
        if( p.find(m2) == p.end() ){
            group[m2] = 1;
            p[m2] = m2;
        }
        m1 = find(m1);
        m2 = find(m2);
        if( m1 != m2 ){
            group[m1] += group[m2];
            group.erase(m2);
            p[m2] = m1;
        }
    }

    void save(){
        clean = p;
        group2 = group;
    }
    void load(){
        p = clean;
        group = group2;
    }
    void infect(int m, int n){
        combine(m, n);
        m = find(m);
        group[m] = 0;
    }
    
};

class Solution {
public:
    int minMalwareSpread(vector<vector<int>>& graph, vector<int>& initial) {
        unordered_set<int> malware(initial.begin(), initial.end());
        Union un;
        sort(initial.begin(), initial.end());
        for( int i = 0; i<graph.size(); i++ ){
            if( malware.find(i) == malware.end() ){
                for( int j = 0; j < graph[i].size(); j++ ){
                    if( graph[i][j] && malware.find(j) == malware.end() ){
                        un.combine(i,j);
                    }
                }
            }
        }
        un.save();
        int ans = initial[0];
        int clean_num = 0;
        for( int i = 0; i<initial.size(); i++ ){
            for (int j = 0; j<initial.size(); j++){
                if( i == j ) continue;
                int node = initial[j];
                for( int k = 0; k<graph[node].size(); k++){
                    if(graph[node][k] && k != initial[i]){
                        un.infect(node, k);

                    }
                }
            }
            int num = 0;
            for( auto it : un.group){
                num += it.second;
            }
            if( num > clean_num){
                ans = initial[i];
                clean_num = num;
            }
            un.load();
        }
        return ans;
    }
};